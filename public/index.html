<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DISCOVER CHHATTISGARH </title>
<style>
  :root{ --bg:#0b1020; --card:#0f1724; --accent:#3b82f6; color-scheme: dark; }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#05060a,#071029);font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  header{padding:12px 18px;color:#dbeafe}
  header h1{margin:0;font-size:18px;letter-spacing:0.2px}
  #app{display:grid;grid-template-columns:300px 1fr;gap:12px;padding:12px;height:calc(100% - 60px);box-sizing:border-box}
  .panel{background:var(--card);border-radius:10px;padding:12px;box-shadow:0 6px 24px rgba(2,6,23,0.6);overflow:auto}
  #placesList button{display:block;width:100%;text-align:left;padding:10px;border-radius:8px;border:0;background:rgba(255,255,255,0.02);color:#d1d5db;margin-bottom:8px;cursor:pointer}
  #placesList button:hover{background:rgba(255,255,255,0.03)}
  #preview{position:relative;height:100%;display:flex;flex-direction:column}
  canvas{width:100%;height:100%;display:block;border-radius:10px;background:#000}
  #controls{margin-top:8px;display:flex;gap:8px;align-items:center}
  .btn{padding:8px 12px;border-radius:8px;border:0;background:var(--accent);color:white;cursor:pointer}
  .hotspot{position:absolute;transform:translate(-50%,-50%);width:36px;height:36px;border-radius:999px;background:rgba(255,255,255,0.08);display:flex;align-items:center;justify-content:center;color:#fff;font-size:12px;border:2px solid rgba(255,255,255,0.12)}
  #hot1{left:60%;top:45%}
  footer{color:#94a3b8;padding:10px 18px;font-size:13px}
  @media (max-width:900px){#app{grid-template-columns:1fr}}
</style>
</head>
<body>
<header><h1>Discover CG â€” EK Virtual Safar </h1></header>
<div id="app">
  <aside class="panel" id="left">
    <h3 style="margin-top:0;color:#e6eefc">Places</h3>
    <div id="placesList">
      <!-- Example place buttons -->
      <!-- <!-- <button data-panorama="">Sample Panorama</button> -->
      <button data-panorama="assets/panoramas/c-block.jpg">C-BLOCK GECR</button> 
      <button data-panorama="assets/panoramas/city.jpg">My City</button>
      <button data-panorama="assets/panoramas/va.jpg">VS&T</button>
    </div>
    <div style="height:12px"></div>
    <div style="color:#cbd5e1;font-size:13px">Controls: drag to look, scroll to zoom, click hotspot to teleport view.</div>
  </aside>

  <section class="panel" id="preview">
    <canvas id="glcanvas" width="1280" height="720"></canvas>
    <div id="controls">
      <button id="enterVr" class="btn">Enter VR (if available)</button>
      <button id="resetView" class="btn" style="background:#111827">Reset View</button>
      <label style="color:#cbd5e1;margin-left:8px">FOV <input id="fov" type="range" min="40" max="100" value="60" style="vertical-align:middle"></label>
    </div>

    <!-- a simple clickable hotspot (positioned in DOM for demo) -->
    <div id="hot1" class="hotspot" title="Hotspot: click to go">GO</div>
  </section>
</div>

<footer>Discover CHHATTISGARH <code>public/assets/panoramas/sample.jpg</code> and start your Node server.</footer>

<script>
/* ========= Minimal WebGL 360 viewer (self-contained) ========= */

const canvas = document.getElementById('glcanvas');
const gl = canvas.getContext('webgl', { antialias: true });
if(!gl) alert('WebGL not supported');

function resizeCanvas() {
  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  const width = canvas.clientWidth * dpr;
  const height = Math.max(300, canvas.clientHeight * dpr);
  if (canvas.width !== width || canvas.height !== height) {
    canvas.width = width; canvas.height = height;
  }
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* ---- shaders ---- */
const VS = `
attribute vec3 aPos;
attribute vec2 aUV;
uniform mat4 uProj, uView;
varying vec2 vUV;
void main(){ vUV = aUV; gl_Position = uProj * uView * vec4(aPos,1.0); }
`;
const FS = `
precision mediump float;
varying vec2 vUV;
uniform sampler2D uTex;
void main(){ vec3 c = texture2D(uTex, vUV).rgb; gl_FragColor = vec4(c,1.0); }
`;

/* ---- compile helpers ---- */
function compileShader(src, type) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(s));
    throw new Error('Shader compile error');
  }
  return s;
}
function createProgram(vs, fs) {
  const p = gl.createProgram();
  gl.attachShader(p, compileShader(vs, gl.VERTEX_SHADER));
  gl.attachShader(p, compileShader(fs, gl.FRAGMENT_SHADER));
  gl.linkProgram(p);
  if(!gl.getProgramParameter(p, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(p));
    throw new Error('Program link error');
  }
  return p;
}
const prog = createProgram(VS, FS);
gl.useProgram(prog);
const aPos = gl.getAttribLocation(prog, 'aPos');
const aUV  = gl.getAttribLocation(prog, 'aUV');
const uProj = gl.getUniformLocation(prog, 'uProj');
const uView = gl.getUniformLocation(prog, 'uView');
const uTex  = gl.getUniformLocation(prog, 'uTex');

/* ---- sphere geometry (inside-facing) ---- */
function makeSphere(radius=50, latBands=60, longBands=60){
  const positions=[], uvs=[], indices=[];
  for(let lat=0; lat<=latBands; lat++){
    const theta = lat * Math.PI / latBands;
    const sinT = Math.sin(theta), cosT = Math.cos(theta);
    for(let lon=0; lon<=longBands; lon++){
      const phi = lon * 2 * Math.PI / longBands;
      const sinP = Math.sin(phi), cosP = Math.cos(phi);
      const x = radius * sinT * cosP;
      const y = radius * cosT;
      const z = radius * sinT * sinP;
      positions.push(x,y,z);
      const u = 1 - (lon / longBands);
      const v = lat / latBands;
      uvs.push(u,v);
    }
  }
  for(let lat=0; lat<latBands; lat++){
    for(let lon=0; lon<longBands; lon++){
      const first = (lat * (longBands+1)) + lon;
      const second = first + longBands + 1;
      // inside-facing triangles (flip winding)
      indices.push(first, second, first+1);
      indices.push(second, second+1, first+1);
    }
  }
  return {positions:new Float32Array(positions), uvs:new Float32Array(uvs), indices:new Uint16Array(indices)};
}

const sph = makeSphere(50, 40, 60);
const posBuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, posBuf); gl.bufferData(gl.ARRAY_BUFFER, sph.positions, gl.STATIC_DRAW);
const uvBuf  = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, uvBuf);  gl.bufferData(gl.ARRAY_BUFFER, sph.uvs, gl.STATIC_DRAW);
const ibo    = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, sph.indices, gl.STATIC_DRAW);

/* ---- enable attributes ---- */
gl.bindBuffer(gl.ARRAY_BUFFER, posBuf); gl.enableVertexAttribArray(aPos); gl.vertexAttribPointer(aPos,3,gl.FLOAT,false,0,0);
gl.bindBuffer(gl.ARRAY_BUFFER, uvBuf);  gl.enableVertexAttribArray(aUV);  gl.vertexAttribPointer(aUV,2,gl.FLOAT,false,0,0);

/* ---- texture loader ---- */
let texture = null;
function loadTexture(url){
  const img = new Image();
  img.crossOrigin = 'anonymous';
  img.onload = ()=>{
    if(texture) gl.deleteTexture(texture);
    texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,img);

    // Check if image is power of two
    function isPowerOf2(x) { return (x & (x - 1)) === 0; }
    if (isPowerOf2(img.width) && isPowerOf2(img.height)) {
      gl.generateMipmap(gl.TEXTURE_2D);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
    } else {
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    }
  };
  img.src = url;
}

/* ---- simple view / camera math ---- */
let yaw = 0, pitch = 0, targetYaw = 0, targetPitch = 0, fov = 60;
function mat4_perspective(fovDeg, aspect, near=0.1, far=1000){
  const f = 1/Math.tan((fovDeg*Math.PI/180)/2);
  const nf = 1/(near - far);
  const out = new Float32Array(16);
  out[0] = f / aspect; out[5] = f; out[10] = (far + near) * nf; out[11] = -1; out[14] = (2 * far * near) * nf;
  return out;
}
function mat4_identity(){ const o = new Float32Array(16); o[0]=o[5]=o[10]=o[15]=1; return o; }
function mat4_rotate(out, ang, axis){
  const x=axis[0], y=axis[1], z=axis[2];
  const len = Math.hypot(x,y,z); if(!len) return;
  const nx=x/len, ny=y/len, nz=z/len;
  const s=Math.sin(ang), c=Math.cos(ang), t=1-c;
  const r = [
    t*nx*nx + c, t*nx*ny - s*nz, t*nx*nz + s*ny, 0,
    t*nx*ny + s*nz, t*ny*ny + c, t*ny*nz - s*nx, 0,
    t*nx*nz - s*ny, t*ny*nz + s*nx, t*nz*nz + c, 0,
    0,0,0,1
  ];
  // out = r * out
  const tmp = new Float32Array(16);
  for(let row=0; row<4; row++){
    for(let col=0; col<4; col++){
      let sum=0;
      for(let k=0;k<4;k++) sum += r[row*4+k] * out[k*4+col];
      tmp[row*4+col]=sum;
    }
  }
  out.set(tmp);
}

/* ---- input handling: drag-to-rotate, wheel to zoom ---- */
let dragging=false, lastX=0, lastY=0;
canvas.addEventListener('mousedown', e => { dragging=true; lastX=e.clientX; lastY=e.clientY; canvas.style.cursor='grabbing'; });
window.addEventListener('mouseup', ()=>{ dragging=false; canvas.style.cursor='default'; });
window.addEventListener('mousemove', e => {
  if(!dragging) return;
  const dx = e.clientX - lastX, dy = e.clientY - lastY;
  targetYaw += dx * 0.006; targetPitch += dy * 0.006;
  lastX = e.clientX; lastY = e.clientY;
});
canvas.addEventListener('touchstart', e => { if(e.touches.length===1){ lastX=e.touches[0].clientX; lastY=e.touches[0].clientY; } });
canvas.addEventListener('touchmove', e => {
  if(e.touches.length!==1) return;
  const dx = e.touches[0].clientX - lastX, dy = e.touches[0].clientY - lastY;
  targetYaw += dx * 0.006; targetPitch += dy * 0.006;
  lastX = e.touches[0].clientX; lastY = e.touches[0].clientY; e.preventDefault();
},{passive:false});
canvas.addEventListener('wheel', e => { fov = Math.min(100, Math.max(40, fov + e.deltaY * 0.02)); document.getElementById('fov').value = fov; });

/* ---- simple animation loop ---- */
function draw(){
  resizeCanvas();
  gl.viewport(0,0,gl.canvas.width, gl.canvas.height);
  gl.clearColor(0,0,0,1); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  gl.enable(gl.DEPTH_TEST);

  // smooth damp
  yaw += (targetYaw - yaw) * 0.12;
  pitch += (targetPitch - pitch) * 0.12;
  pitch = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, pitch));

  // projection & view
  const proj = mat4_perspective(fov, gl.canvas.width / gl.canvas.height);
  let view = mat4_identity();
  mat4_rotate(view, -pitch, [1,0,0]);
  mat4_rotate(view, -yaw, [0,1,0]);

  gl.uniformMatrix4fv(uProj, false, proj);
  gl.uniformMatrix4fv(uView, false, view);

  if (texture) {
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.uniform1i(uTex, 0);
  }

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
  gl.drawElements(gl.TRIANGLES, sph.indices.length, gl.UNSIGNED_SHORT, 0);

  requestAnimationFrame(draw);
}
requestAnimationFrame(draw);

/* ---- UI: load panorama buttons ---- */
document.querySelectorAll('#placesList button').forEach(b=>{
  b.addEventListener('click', ()=> {
    const p = b.dataset.panorama;
    loadTexture(p);
  });
});

/* ---- load default panorama ---- */
loadTexture('assets/panoramas/va.jpg');

/* ---- reset view button ---- */
document.getElementById('resetView').addEventListener('click', ()=>{ targetYaw=0; targetPitch=0; fov=60; document.getElementById('fov').value=60; });

/* ---- fov control ---- */
document.getElementById('fov').addEventListener('input', e => { fov = +e.target.value; });

/* ---- simple hotspot and teleport animation ---- */
const hot = document.getElementById('hot1');
hot.addEventListener('click', ()=> {
  // hardcoded spherical target: yaw = 1.2rad, pitch = -0.12rad (pick any)
  const tgtYaw = 1.2, tgtPitch = -0.12;
  // animate targetYaw/targetPitch smoothly
  const dur = 600, start = performance.now(), sy = targetYaw, sp = targetPitch;
  (function anim(t){
    const p = Math.min(1, (t - start) / dur);
    const ease = 0.5 - 0.5 * Math.cos(Math.PI * p);
    targetYaw = sy + (tgtYaw - sy) * ease;
    targetPitch = sp + (tgtPitch - sp) * ease;
    if (p < 1) requestAnimationFrame(anim);
  })(start);
});

/* ---- simple pointer-lock toggle (click canvas) ---- */
canvas.addEventListener('click', ()=> {
  if (!document.pointerLockElement) canvas.requestPointerLock?.();
});

/* ---- WebXR start (basic) ---- */
const xrBtn = document.getElementById('enterVr');
xrBtn.addEventListener('click', async ()=>{
  if (!navigator.xr) { alert('WebXR not supported in this browser'); return; }
  try {
    const supported = await navigator.xr.isSessionSupported('immersive-vr');
    if (!supported) { alert('immersive-vr not available'); return; }
    const session = await navigator.xr.requestSession('immersive-vr');
    await gl.makeXRCompatible();
    const xrLayer = new XRWebGLLayer(session, gl);
    session.updateRenderState({ baseLayer: xrLayer });
    const refSpace = await session.requestReferenceSpace('local');

    session.requestAnimationFrame(function onXRFrame(time, xrFrame){
      const session = xrFrame.session;
      session.requestAnimationFrame(onXRFrame);
      const pose = xrFrame.getViewerPose(refSpace);
      if(!pose) return;
      // For simplicity: render first view using pose to set view matrix.
      const view = pose.views[0];
      // view.transform.inverse.matrix is Float32Array(16) if available - use it as view matrix
      const viewMat = view.transform.inverse.matrix;
      gl.viewport(0,0, xrLayer.getViewport(view).width, xrLayer.getViewport(view).height);
      gl.uniformMatrix4fv(uProj, false, view.projectionMatrix);
      gl.uniformMatrix4fv(uView, false, viewMat);
      if (texture) { gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, texture); gl.uniform1i(uTex,0); }
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
      gl.drawElements(gl.TRIANGLES, sph.indices.length, gl.UNSIGNED_SHORT, 0);
    });

  } catch(err){
    console.error(err);
    alert('Failed to start XR: ' + err.message);
  }
});
</script>
</body>
</html>
